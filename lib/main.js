// Generated by CoffeeScript 1.8.0

/*
#===========================================================================================================



888      8888888888 888     888 8888888888 888         .d8888b.  8888888888 8888888b.  888     888 8888888888 8888888b.
888      888        888     888 888        888        d88P  Y88b 888        888   Y88b 888     888 888        888   Y88b
888      888        888     888 888        888        Y88b.      888        888    888 888     888 888        888    888
888      8888888    Y88b   d88P 8888888    888         "Y888b.   8888888    888   d88P Y88b   d88P 8888888    888   d88P
888      888         Y88b d88P  888        888            "Y88b. 888        8888888P"   Y88b d88P  888        8888888P"
888      888          Y88o88P   888        888              "888 888        888 T88b     Y88o88P   888        888 T88b
888      888           Y888P    888        888        Y88b  d88P 888        888  T88b     Y888P    888        888  T88b
88888888 8888888888     Y8P     8888888888 88888888    "Y8888P"  8888888888 888   T88b     Y8P     8888888888 888   T88b



#===========================================================================================================
 */


/* TAINT expedient until we have started HOLLERITH2 */

(function() {
  var $, D, D2, HOLLERITH, SBLVL, SOBA, TEXT, TRM, TYPES, alert, badge, db_route, debug, help, info, new_db, njs_fs, remove_db, rmrf, rpr, urge, warn, whisper, wrap_as_socket_stream,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  HOLLERITH = {};


  /* TAINT should choose more descriptive name */

  HOLLERITH._XXX_lte_from_gte = function(gte) {
    var R, length;
    length = Buffer.byteLength(gte);
    R = new Buffer(1 + length);
    R.write(gte);
    R[length] = 0xff;
    return R;
  };

  njs_fs = require('fs');

  TEXT = require('coffeenode-text');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'soba-level-server';

  info = TRM.get_logger('info', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  urge = TRM.get_logger('urge', badge);

  whisper = TRM.get_logger('whisper', badge);

  help = TRM.get_logger('help', badge);

  SOBA = require('soba-server');

  new_db = require('level');


  /* https://github.com/loveencounterflow/pipedreams */

  D = require('pipedreams');

  D2 = require('pipedreams2');

  $ = D.remit.bind(D);

  rmrf = require('rimraf');


  /* https://github.com/nkzawa/socket.io-stream */

  wrap_as_socket_stream = require('socket.io-stream');

  this.new_db = function(db_route) {

    /* TAINT make configurable */
    var R, db, sb;
    sb = SOBA.new_server();
    db = new_db(db_route);
    R = {
      '~isa': 'SOBA-LEVEL/db',
      '%soba-server': sb,
      '%level-db': db
    };
    return R;
  };

  this.get_socket_router = function(me) {
    return SOBA.get_router(me['%soba-server']);
  };

  this.get_app = function(me) {
    return SOBA.get_app(me['%soba-server']);
  };

  this.get_sio_server = function(me) {
    return SOBA.get_sio_server(me['%soba-server']);
  };

  this.get_soba_server = function(me) {
    return me['%soba-server'];
  };

  this.get_level_db = function(me) {
    return me['%level-db'];
  };

  this.get_level_db_route = function(me) {
    return (this.get_level_db(me))['location'];
  };

  this.get_verbose = function(me) {
    return (this.get_soba_server(me))['verbose'];
  };

  this.serve = function() {
    var server;
    return server = server.listen(port, function() {
      var host, port, _ref;
      help("server process running on Node v" + process.versions['node']);
      _ref = server.address(), host = _ref.address, port = _ref.port;
      return help("ソバ Server listening to http://" + host + ":" + port);
    });
  };


  /* TAINT not a SOBA-triggerable method for now; must deal with new DB connection without touching
    `%level-db` object in `me`
   */

  this._remove_db = function(db_route, handler) {
    warn("erasing database at " + db_route);
    rmrf.sync(db_route);
    warn("erased database at " + db_route);
    return handler(null);
  };

  this.put = function(me, socket, key, value, handler) {
    var _ref;
    if (handler == null) {
      _ref = [null, value], value = _ref[0], handler = _ref[1];
    }
    return me['%level-db'].put(key, value, handler);
  };

  this.get = function(me, socket, key, handler) {
    throw new Error('not implemented');
  };

  this.dump = function(me, settings, handler) {
    var Z, db, format, input, limit, prefix, query, skip_count, soba_server, _ref, _ref1, _ref2, _ref3;
    format = (_ref = settings != null ? settings['format'] : void 0) != null ? _ref : 'one-by-one';
    limit = (_ref1 = settings != null ? settings['take'] : void 0) != null ? _ref1 : 10;
    skip_count = (_ref2 = settings != null ? settings['skip'] : void 0) != null ? _ref2 : 0;
    prefix = (_ref3 = settings != null ? settings['prefix'] : void 0) != null ? _ref3 : '';
    db = this.get_level_db(me);
    soba_server = this.get_soba_server(me);
    query = {
      gte: prefix,
      lte: HOLLERITH._XXX_lte_from_gte
    };
    input = db.createReadStream(query);
    switch (format) {
      case 'list':
        Z = [];
        break;
      case 'one-by-one':
        null;
        break;
      default:
        return handler(new Error("unknown format " + (rpr(format))));
    }

    /* TAINT how to signal end of stream when `format is 'one-by-one'`? */

    /* TAINT should we identify response with a request ID?
      how do clients sort out responses from overlapping requests`
     */
    return input.pipe(D.$take(limit)).pipe(D2.$skip_first(skip_count)).pipe($((function(_this) {
      return function(facet, send, end) {
        if (facet != null) {
          switch (format) {
            case 'list':
              Z.push(facet);
              break;
            case 'one-by-one':
              handler(null, facet);
          }
          send(1);
        }
        if (end != null) {
          switch (format) {
            case 'list':
              handler(null, Z);
              break;
            case 'one-by-one':
              handler(null, null);
          }
          return end();
        }
      };
    })(this)));
  };

  this.demo = function(db_route) {
    var db, level_db, router, sio_server;
    db = SBLVL.new_db(db_route);
    level_db = SBLVL.get_level_db(db);
    router = SBLVL.get_socket_router(db);
    SOBA.serve(db);
    sio_server = SBLVL.get_sio_server(db);
    return sio_server.on('connection', (function(_this) {
      return function(socket) {
        var sb;
        debug('©81uDb', 'connected');
        sb = SBLVL.get_soba_server(db);

        /* OBS: we're using pipedreams-style method signatures here where payload is always single argument */
        socket.on('get', function(_arg) {
          var key;
          key = _arg[0];
          return SBLVL.get(db, socket, key, function(error) {
            if (error != null) {
              throw error;
            }
            if (_this.get_verbose(db)) {
              return urge('ready:', 'get', key);
            }
          });
        });

        /* OBS: we're using pipedreams-style method signatures here where payload is always single argument */
        socket.on('put', function(_arg) {
          var key, value;
          key = _arg[0], value = _arg[1];
          return SBLVL.put(db, socket, key, value, function(error) {
            if (error != null) {
              throw error;
            }
            if (_this.get_verbose(db)) {
              return urge('ready:', 'put', key);
            }
          });
        });

        /* TAINT not sure about that `rsvp` name; it shouldn't be `handler`, as there's no initial error
          argument, just payload.
         */
        (wrap_as_socket_stream(socket)).on('dump', {
          encoding: 'utf-8'
        }, function(output, settings) {

          /* TAINT using `output,write()` directly doesn't work, using through stream as arbiter */
          var batch_idx, format, through, _ref;
          through = D.create_throughstream();
          through.pipe(output);
          batch_idx = 0;
          format = (_ref = settings != null ? settings['format'] : void 0) != null ? _ref : 'one-by-one';
          return SBLVL.dump(db, settings, function(error, data) {
            var event;
            if (error != null) {
              throw error;
            }
            if (_this.get_verbose(db)) {
              urge('ready:', 'dump');
            }
            if (data != null) {
              switch (format) {
                case 'one-by-one':
                case 'list':
                  event = ['batch', batch_idx, data];
                  batch_idx += 1;
                  break;
                default:

                  /* TAINT pass error on */
                  throw new Error("unknown format " + (rpr(format)));
              }
              return through.write((JSON.stringify(event)) + '\n');
            } else {
              return through.end();
            }
          });
        });
        return socket.on('remove-db', function() {
          return SBLVL.dump(db, socket, settings, function(error) {
            if (error != null) {
              throw error;
            }
            return urge('ready:', 'remove-db');
          });
        });
      };
    })(this));

    /*
    router.on 'get', ( socket, P, next ) =>
      debug 'get', P
      next()
    
    router.on 'put', ( socket, P, next ) =>
      debug 'put', P
      next()
     */
  };

  if ((module.parent == null) || __indexOf.call(process.argv, 'serve') >= 0) {
    SBLVL = this;
    db_route = njs_path.join(__dirname, '../../data/jizura-mojikura');
    remove_db = false;
    if (remove_db) {
      SBLVL._remove_db(db_route, function() {
        return SBLVL.demo(db_route);
      });
    } else {
      SBLVL.demo(db_route);
    }
  }

}).call(this);
